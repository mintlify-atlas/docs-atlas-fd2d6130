---
title: "Broccoli"
description: "Core virtual file system type and methods"
---

## Overview

The `Broccoli` type is the main entry point for the virtual file system. It provides methods to access, traverse, and serve brotli-compressed assets embedded in your Go binary.

```go
type Broccoli struct {
    // private fields
}
```

<Note>
Broccoli instances are typically generated by the `broccoli` CLI tool using `go:generate` directives:

```go
//go:generate broccoli -src=public,assets -o br -var br
```
</Note>

## Creating Instances

### fs.New

Creates a new Broccoli instance from a compressed bundle. This function is automatically called in generated code.

```go
func New(opt bool, bundle []byte) *Broccoli
```

<ParamField path="opt" type="bool">
  Enable optional (lazy) decompression. When `true`, files are decompressed on first access. When `false`, all files are decompressed immediately at initialization.
</ParamField>

<ParamField path="bundle" type="[]byte">
  The compressed bundle bytes containing all embedded files.
</ParamField>

**Example generated code:**

```go
// Code generated by broccoli
package main

import "aletheia.icu/broccoli/fs"

var assets = fs.New(false, []byte("...compressed data..."))
```

<Warning>
This function panics if the bundle is invalid or decompression fails. It's only intended to be called from generated code, not directly by users.
</Warning>

## Methods

### Open

Opens the named file for reading and returns an `http.File` interface.

```go
func (br *Broccoli) Open(path string) (http.File, error)
```

<ParamField path="path" type="string" required>
  The path to the file to open. The path is normalized automatically (leading `./` and `/` are stripped).
</ParamField>

<ResponseField name="http.File" type="http.File">
  A file handle that can be used for reading. Returns the `File` type in production mode.
</ResponseField>

<ResponseField name="error" type="error">
  Returns `os.ErrNotExist` if the file is not found in the bundle.
</ResponseField>

<Tabs>
  <Tab title="Production Mode">
    ```go
    file, err := br.Open("styles/main.css")
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()
    
    // Read the file contents
    data, err := io.ReadAll(file)
    ```
  </Tab>
  <Tab title="Development Mode">
    ```go
    // In development mode, Open reads from the local filesystem
    br.Development(true)
    
    file, err := br.Open("styles/main.css")
    // Reads from actual disk file instead of bundle
    ```
  </Tab>
</Tabs>

<Note>
In development mode, `Open` delegates to `os.Open` and reads from the actual file system instead of the embedded bundle.
</Note>

---

### Stat

Returns file information for the named file without opening it.

```go
func (br *Broccoli) Stat(path string) (os.FileInfo, error)
```

<ParamField path="path" type="string" required>
  The path to the file. The path is normalized automatically.
</ParamField>

<ResponseField name="os.FileInfo" type="os.FileInfo">
  File information including name, size, mode, modification time, and whether it's a directory.
</ResponseField>

<ResponseField name="error" type="error">
  Returns `os.ErrNotExist` if the file is not found.
</ResponseField>

```go
info, err := br.Stat("images/logo.png")
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Name: %s\n", info.Name())
fmt.Printf("Size: %d bytes\n", info.Size())
fmt.Printf("Modified: %v\n", info.ModTime())
fmt.Printf("Is Directory: %v\n", info.IsDir())
```

---

### Walk

Walks the file tree rooted at the specified path, calling a function for each file or directory.

```go
func (br *Broccoli) Walk(root string, walkFn filepath.WalkFunc) error
```

<ParamField path="root" type="string" required>
  The root path to start walking from. The path is normalized automatically.
</ParamField>

<ParamField path="walkFn" type="filepath.WalkFunc" required>
  A callback function called for each file and directory. The function signature is:
  
  ```go
  func(path string, info os.FileInfo, err error) error
  ```
</ParamField>

<ResponseField name="error" type="error">
  Returns any error from the walk function. All errors are filtered through `walkFn`.
</ResponseField>

<Tabs>
  <Tab title="List All Files">
    ```go
    err := br.Walk("public", func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        if !info.IsDir() {
            fmt.Printf("%s (%d bytes)\n", path, info.Size())
        }
        
        return nil
    })
    ```
  </Tab>
  <Tab title="Find Specific Files">
    ```go
    // Find all CSS files
    err := br.Walk("styles", func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        if strings.HasSuffix(path, ".css") {
            fmt.Println("Found CSS:", path)
        }
        
        return nil
    })
    ```
  </Tab>
</Tabs>

<Note>
- Files are walked in lexical order, making the output deterministic
- Walk does not follow symbolic links
- In development mode, `Walk` delegates to `filepath.Walk` on the actual file system
</Note>

---

### Development

Controls the development mode behavior of the Broccoli file system.

```go
func (br *Broccoli) Development(mode bool)
```

<ParamField path="mode" type="bool" required>
  Set to `true` to enable development mode, `false` to use the embedded bundle.
</ParamField>

<Tabs>
  <Tab title="Environment-Based">
    ```go
    // Enable development mode when not in production
    if os.Getenv("PRODUCTION") == "" {
        br.Development(true)
    }
    
    // Now all Open, Stat, and Walk operations use the local filesystem
    http.ListenAndServe(":8080", br.Serve("public"))
    ```
  </Tab>
  <Tab title="Conditional">
    ```go
    // Enable for local development
    br.Development(true)
    
    // Make changes to files on disk and see them immediately
    // without regenerating the bundle
    ```
  </Tab>
</Tabs>

<Note>
When development mode is enabled:
- `Open()` uses `os.Open()` to read from disk
- `Stat()` uses `os.Open()` and `Stat()` on the actual file
- `Walk()` uses `filepath.Walk()` on the actual file system

This is useful for rapid development cycles when you want to see file changes without regenerating the bundle.
</Note>

---

### Serve

Returns an `http.Handler` that serves files from the virtual file system with a specified directory prefix.

```go
func (br *Broccoli) Serve(dir string) http.Handler
```

<ParamField path="dir" type="string" required>
  The directory prefix to prepend to all file paths. Leading and trailing slashes are automatically trimmed.
</ParamField>

<ResponseField name="http.Handler" type="http.Handler">
  A handler that can be used with `http.ListenAndServe` or any HTTP router. Returns a `Server` instance wrapped with `http.FileServer`.
</ResponseField>

<Tabs>
  <Tab title="Basic Usage">
    ```go
    //go:generate broccoli -src=public -o assets -var br
    
    func main() {
        // Serve files from the "public" directory prefix
        http.ListenAndServe(":8080", br.Serve("public"))
    }
    ```
  </Tab>
  <Tab title="With Router">
    ```go
    mux := http.NewServeMux()
    
    // Serve static assets under /static/
    mux.Handle("/static/", http.StripPrefix("/static/", br.Serve("public")))
    
    // Other routes
    mux.HandleFunc("/api/", apiHandler)
    
    http.ListenAndServe(":8080", mux)
    ```
  </Tab>
  <Tab title="Multiple Directories">
    ```go
    //go:generate broccoli -src=public,assets,templates -o br -var br
    
    mux := http.NewServeMux()
    mux.Handle("/public/", http.StripPrefix("/public/", br.Serve("public")))
    mux.Handle("/assets/", http.StripPrefix("/assets/", br.Serve("assets")))
    
    http.ListenAndServe(":8080", mux)
    ```
  </Tab>
</Tabs>

<Note>
The `Serve` method creates a `Server` instance with the specified prefix and wraps it with `http.FileServer`, providing automatic:
- Content-Type detection
- Range request support
- Directory listing (for directories in the bundle)
- 304 Not Modified responses based on modification time
</Note>

## Usage Example

```go
package main

import (
    "log"
    "net/http"
    "os"
)

//go:generate broccoli -src=public,assets -o assets -var br

func init() {
    // Enable development mode when not in production
    if os.Getenv("PRODUCTION") == "" {
        br.Development(true)
    }
    
    // Walk through all files to verify bundle
    br.Walk("public", func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        log.Printf("Bundled: %s (%d bytes)\n", path, info.Size())
        return nil
    })
}

func main() {
    http.ListenAndServe(":8080", br.Serve("public"))
}
```